UML is the most prevalent OO modeling language.

ArgoUML is tool for Object Oriented Analysis and Design.

ArgoUML is based on UML v1.4, which was adopted by OMG in September 2001. The current official
version, supported by ArgoUML, is UML v1.4.2 dated July 2004, adopted as ISO/IEC 19501. The latest
UML version is UML v2.1.2, from November 2007.

Why ArgoUML:
i) it makes use of ideas from cognitive psychology,
ii) it is based on open standards,
iii) it is 100% pure Java, and 
iv) it is an open source project


It is important to understand that UML is a notation for OOA&D. It does not prescribe any particular
process. Whatever process is adopted, it must take the system being constructed through a number of
phases.

1. Requirements Capture
2. Analysis    :Abstraction of system
3. Design      :Moving from abstraction of the problem to its realization in concrete terms
4. Build Phase :Take the actual design and write it in a real programming language(V & V & Documentation)

1. Requirement Capture:
Our requirements capture will use the UML concept of ##Use Cases##. Starting with a ##Vision Document## we
will see how Use Cases can be developed to describe all aspects of the system's behavior in the problem
domain.

2. Analysis:
During the analysis stage, we will introduce the UML concept of classes to allow us to build a top level
view of the objects that will make up the solution -sometimes known as a ##concept diagram##.
We will introduce the UML ##sequence diagram## and ##statechart diagram## to capture requirements for the
overall behavior of the system.
Finally we will take the ##Use Cases## from the requirements capture stage, and recast them in the language
of the solution domain. This will illustrate the UML ideas of ##stereotyping and realization##.

3. Design:
We use the UML ##package diagram## to organize the components of the project. We then revisit the ##class
diagram, sequence diagram and statechart diagram##, to show how they can be used recursively to design
the complete solution.
Finally we shall use the UML ##deployment diagram## to specify how the system will actually be realized.

4. Build:
UML is not really concerned with code writing. However at this stage we will show how ArgoUML can
be used for code generation.
We will also look at how the UML ##Use Case Diagram and Use Case Specification## are invaluable tools
for a test program.


XMI(XML Metadata Interchange)
-----------------------------
XML Metadata Interchange (XMI) is the standard for saving the meta-data that make up a particular
UML model. In principle this will allow you to take the model you have created in ArgoUML and im-
port it into another tool.
This clearly has advantages in allowing UML to meet its goal of being a standard for communication
between designers.

Code Generation
---------------
Code Generated by ArgoUML: ArgoUML can generate code.
It is possible to compile your generated code with ArgoUML, you still need to implement method bod-
ies, though, to get usable results.

Generating Code for Methods
At the moment you cannot write code for methods (operations) within ArgoUML. The source pane is
editable, but the changes are ignored. ArgoUML is a pure design tool for now, no IDE functionality but
the desire is there. You might consider using Forte and ArgoUML together -it's a good work around!
You can help us out there if you'd like!

Rule of Thumb
--------------
A useful rule of thumb is that any practical project ought to require no more than about 30 use cases
(if it needs more, it should be broken into separate projects).


PHASE-1:Requirement Capture
===========================
Basic use case diagram for an ATM system
=> Active actors initiate interaction with the system(eg. Customer is an active actor)
=> Interaction with passive actors is initiated by the system(eg.Central computer is a passive actor)
=> Multiplicity of associations between actors and use cases.
   By this we mean how many instances of an actor interact with how many instances of the use case.

=> The decomposition of a use case into simpler sub-use cases is shown in UML by using an include rela-
   tionship, a dotted arrow from the main use case to the sub-use cases, with the label «include».
=> We also want to show a use case that is an extension to an existing use case to cater for a particular cir-
   cumstance. In the ATM example we have a use case covering routine maintenance of the ATM, “Maintain Equip-
   ment”. We also want to cover the special case of an unscheduled repair caused by the ATM detecting an
   internal fault.

UseCase Specification
---------------------
A typical use case specification will include the following sections.
1. Name: The name of the use case to which this relates.
2. Goal: A one or two line summary of what this use case achieves for its actors.
3. Actors: The actors involved in this use case, and any context regarding their involvement.
4. Pre-condition: These would be better named “pre-assumptions”
5. Basic Flow: The linear sequence of steps that describe the behavior of the use case in the “normal”
   scenario
6. Alternate Flows. A series of linear sequences describing each of the alternative behaviors to the ba-
   sic flow
7. Post-conditions: These would be better named “post-assumptions”
8. Requirements: In an ideal world the vision document, use case diagrams, use case specifications and
   supplementary requirements specification would form the requirements for a project.

For example we might give the following sequence of steps for the basic flow of the use case "Withdraw
Cash" in our ATM example.
1. Customer indicates a receipt is required.
2. Customer enters amount of cash required.
3. ATM verifies with the central computer that the customer can make this withdrawal.
4. ATM dispenses cash to the customer.
5. ATM issues receipt to customer.
Remember this is a sub-use case included in the main “Use ATM” use case, which will presumably
handle checking of cards and PINs before invoking this included use case.

Stakeholders
-------------
Among the stakeholders for this system are the Engineering Department, the Maintenance Department,
and the Central Computer Facility. The full list of these stakeholders and the specific individuals repres-
enting them are.
• Engineering. Bunny, Bugs
• Maintenance. Hardy, Oliver
• Computer Facility. Laurel, Stanley
• Chief Executive Officer. Hun, Atilla The
• Marketing. Harry, Oil Can


PHASE2:Analysis
=================
Analysis is the process of taking the “customer” requirements and re-casting them in the language of,
and from the perspective of, a putative solution.
Unlike the boundary between Requirements and Analysis Phases, the boundary between Analysis and
Design Phases is inherently blurred.
The key is that analysis should define the solution no further than is necessary to specify the
requirements in the language of the solution.
The model elements in Analysis generally represent a high level of abstraction While the
design phase specifiy the real requirments by keeping language in mind.
=> Class Daigrams
=> Sequence Diagrams
=> Activity Diagrams
=> StateChart Daigrams and etc.

PHASE3:Design
===============
We move from the abstract concepts of analysis to their concrete realization.
=> Class Daigrams
=> Sequence Diagrams
=> Activity Diagrams
=> StateChart Daigrams and etc.


PHASE4:Build
=================
Code Generation
---------------
With the right simulator we could actually execute the design and see if it works.
(ArgoUML does not provide such functionality, but this functionality has been provided in alternative tools.)

ArgoUML does allow you to generate code from the design in several different programming languages.
We, most likely, already in the design had a programming language in mind because some of the design
considerations are to care for a specific language.
The output of this process is the set of files that constitute the program that solves the problem.


Reverse Engineering
-------------------
It is used for two main purposes:
1. To get previously developed classes into the model to build upon.
2. To get a UML view of previously developed classes to understand how they work.
Essentially this does the opposite of Code Generation.

Round-Trip Engineering
----------------------
It makes it possible to switch perspective while doing the design. Create some
classes in a class diagram. Write some code for some of the operations or functions using your favorite
editor. Move the operations from one class to another in the class diagram.
ArgoUML currently does not support this for any language.





















